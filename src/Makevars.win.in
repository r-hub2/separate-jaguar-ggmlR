CXX_STD = CXX17

# Enable C99 format specifiers (%zu, %zd) on MinGW
# Without this, gcc on Windows warns about unknown format character 'z'
PKG_CPPFLAGS_WIN = -D__USE_MINGW_ANSI_STDIO=1

# Vulkan flags (set by configure.win --with-vulkan)
VULKAN_CPPFLAGS = @VULKAN_CPPFLAGS@
VULKAN_LIBS = @VULKAN_LIBS@

# Base include paths and defines
GGML_CPPFLAGS = -I. -Iggml-cpu -Iggml-cpu/arch/x86 \
  -DGGML_VERSION='"0.9.5"' -DGGML_COMMIT='"ggmlR"' \
  -DGGML_USE_CPU $(PKG_CPPFLAGS_WIN)

# --- OpenMP configuration (Windows) ---
#
# On Rtools, gcc and g++ are from the same MinGW toolchain, so
# SHLIB_OPENMP_CFLAGS == SHLIB_OPENMP_CXXFLAGS (both are -fopenmp).
#
# CRAN R CMD check requires strict pairing:
#   - Each SHLIB_OPENMP_* in PKG_C(XX)FLAGS must have a match in PKG_LIBS
#   - PKG_LIBS macro must match the linker language (C++ for this package)
#
# Therefore we use only SHLIB_OPENMP_CXXFLAGS everywhere:
#   - PKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) -- C++ compilation + linker match
#   - PKG_LIBS     = $(SHLIB_OPENMP_CXXFLAGS) -- linker (C++)
#   - PKG_CFLAGS   is not set (C code still gets OpenMP via the toolchain)
#
# The -DGGML_USE_OPENMP define is set conditionally below for all code.
#
ifneq ($(SHLIB_OPENMP_CXXFLAGS),)
  GGML_CPPFLAGS += -DGGML_USE_OPENMP
endif

# Force include R compatibility header for CRAN compliance
# This redirects stdout/stderr/abort to R-safe alternatives
# r_ggml_io.c is compiled separately without this header (see rule below)
PKG_CPPFLAGS = $(GGML_CPPFLAGS) $(VULKAN_CPPFLAGS) -DGGML_R_PACKAGE -include r_ggml_compat.h

# CPU SIMD flags (set by configure.win: individual -msse4.2 -mavx2 etc. or empty)
SIMD_CFLAGS = @SIMD_CFLAGS@

PKG_CFLAGS = $(SIMD_CFLAGS)
PKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) $(SIMD_CFLAGS)
PKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS) $(VULKAN_LIBS)

# GGML library objects (for static library export)
GGML_OBJECTS = \
  r_ggml_io.o \
  ggml.o ggml-alloc.o ggml-quants.o ggml-opt.o gguf.o \
  ggml-backend.o ggml-backend-reg.o ggml-threading.o \
  ggml-cpu/traits.o \
  ggml-cpu/ggml-cpu-backend.o ggml-cpu/ggml-cpu.o \
  ggml-cpu/ops.o ggml-cpu/vec.o \
  ggml-cpu/binary-ops.o ggml-cpu/unary-ops.o ggml-cpu/repack.o \
  ggml-cpu/quants.o ggml-cpu/hbm.o \
  ggml-cpu/arch/x86/cpu-feats.o ggml-cpu/arch/x86/quants.o ggml-cpu/arch/x86/repack.o

# R interface objects
R_INTERFACE_OBJECTS = \
  r_interface.o r_interface_graph.o r_interface_vulkan.o r_interface_scheduler.o \
  r_interface_opt.o r_interface_backend.o r_interface_quants.o

# Vulkan objects (set by configure.win --with-vulkan)
VULKAN_OBJECTS = @VULKAN_OBJECTS@
GGML_OBJECTS += $(VULKAN_OBJECTS)

# All objects for shared library
OBJECTS = $(R_INTERFACE_OBJECTS) $(GGML_OBJECTS)

# Static library for linking by other packages
STATICLIB = libggml.a

$(SHLIB): $(OBJECTS) staticlib

.PHONY: staticlib

staticlib: $(GGML_OBJECTS)
	mkdir -p ../inst/lib
	$(AR) rcs ../inst/lib/$(STATICLIB) $(GGML_OBJECTS)
	strip --strip-debug ../inst/lib/$(STATICLIB) 2>/dev/null || true

# R interface files and r_ggml_io.c include R headers (R.h, Rinternals.h)
# which contain __attribute__((format(printf, ...))). Our macro
# '#define printf r_ggml_printf' would turn this into format(r_ggml_printf, ...)
# which GCC rejects as an unrecognized format type.
# R_GGML_IO_IMPL disables all macro redirections in r_ggml_compat.h.
# These files use only R API (Rprintf, Rf_error), not stdio printf/fprintf,
# so they don't need the redirections.
r_ggml_io.o: PKG_CPPFLAGS += -DR_GGML_IO_IMPL
r_interface.o: PKG_CPPFLAGS += -DR_GGML_IO_IMPL
r_interface_graph.o: PKG_CPPFLAGS += -DR_GGML_IO_IMPL
r_interface_vulkan.o: PKG_CPPFLAGS += -DR_GGML_IO_IMPL
r_interface_scheduler.o: PKG_CPPFLAGS += -DR_GGML_IO_IMPL
r_interface_opt.o: PKG_CPPFLAGS += -DR_GGML_IO_IMPL
r_interface_backend.o: PKG_CPPFLAGS += -DR_GGML_IO_IMPL
r_interface_quants.o: PKG_CPPFLAGS += -DR_GGML_IO_IMPL
